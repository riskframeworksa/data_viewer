<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>South America City Priority Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet (map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Plotly (tiny charts in the sidebar) -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <style>
    :root {
      --bg: #ffffff;
      --fg: #222222;
      --muted: #6b6b6b;
      --border: #dddddd;
      --panel-bg: #f8f8f8;
      --font-main: "Palatino Linotype", "Book Antiqua", Palatino, "Times New Roman", serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 1.25rem;
      font-family: var(--font-main);
      background: var(--bg);
      color: var(--fg);
    }

    .page-header {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    h1 { font-size: 1.6rem; margin: 0; }

    .subtitle {
      margin: 0.25rem 0 0 0;
      font-size: 0.92rem;
      color: var(--muted);
      line-height: 1.25;
      max-width: 900px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(6, minmax(160px, 1fr));
      gap: 0.75rem;
      padding: 0.9rem;
      margin: 0.75rem 0 0.9rem 0;
      background: var(--panel-bg);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
    }

    .control-group { display: flex; flex-direction: column; gap: 0.25rem; }

    .control-group label {
      font-size: 0.82rem;
      color: var(--muted);
    }

    select, input[type="number"], input[type="range"] {
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      font-size: 0.9rem;
      background: #fff;
    }

    .range-row {
      display: grid;
      grid-template-columns: 1fr 62px;
      gap: 0.5rem;
      align-items: center;
    }

    .pill {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 0.8rem;
      color: #333;
      background: #fff;
      white-space: nowrap;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.4fr 0.9fr;
      gap: 0.9rem;
      align-items: start;
    }

    #map {
      height: 610px;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      overflow: hidden;
    }

    .side {
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: #fff;
      padding: 0.85rem 0.85rem 1rem 0.85rem;
    }

    .side h2 { margin: 0 0 0.4rem 0; font-size: 1.1rem; }

    .muted { color: var(--muted); }

    .city-title {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.35rem;
    }

    .badge {
      font-weight: bold;
      border-radius: 0.55rem;
      padding: 0.2rem 0.55rem;
      font-size: 0.82rem;
      border: 1px solid var(--border);
      background: #fff;
    }

    .kv {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.35rem 0.75rem;
      margin: 0.5rem 0 0.6rem 0;
      font-size: 0.9rem;
    }

    .kv .k { color: var(--muted); font-size: 0.82rem; }

    .mini {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.4rem;
      margin: 0.25rem 0 0.6rem 0;
    }

    .mini .box {
      border: 1px solid var(--border);
      border-radius: 0.6rem;
      padding: 0.45rem 0.55rem;
      background: #fbfbfb;
    }

    .mini .box .k { font-size: 0.75rem; color: var(--muted); }
    .mini .box .v { font-size: 0.98rem; font-weight: 600; }

    #bar {
      height: 190px;
      margin-top: 0.2rem;
    }

    .status {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.35;
    }

    .about {
      margin-top: 1rem;
      padding: 1rem 1.2rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: var(--panel-bg);
      color: #444;
      line-height: 1.45;
    }

    .about h3 { margin: 0 0 0.5rem 0; }

    @media (max-width: 1100px) {
      .controls { grid-template-columns: repeat(2, 1fr); }
      .layout { grid-template-columns: 1fr; }
      #map { height: 520px; }
    }
  </style>
</head>
<body>

  <div class="page-header">
    <div>
      <h1>South America City Priority Explorer</h1>
      <p class="subtitle">
        Planner-friendly triage view derived from city-level <span class="pill">Hazard (H)</span> and
        <span class="pill">Adaptive Capacity (S)</span>.
        We define <span class="pill">Vulnerability (V) = 1 − S</span> and compute
        <span class="pill">Priority = 100 × (w<sub>H</sub>·H + (1−w<sub>H</sub>)·V)</span>.
        Use filters to focus on a country/state or show the top <em>N</em> cities by population, imperviousness, or priority.
      </p>
    </div>
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="country">Country</label>
      <select id="country"></select>
    </div>

    <div class="control-group">
      <label for="state">State / Province</label>
      <select id="state" disabled></select>
    </div>

    <div class="control-group">
      <label for="popClass">Population class</label>
      <select id="popClass">
        <option value="all">All</option>
        <option value=">1M">Pop > 1M</option>
        <option value="500k-1M">500k–1M</option>
        <option value="250k-500k">250k–500k</option>
        <option value="100k-250k">100k–250k</option>
        <option value="<100k">Pop < 100k</option>
      </select>
    </div>

    <div class="control-group">
      <label for="rankBy">Select top N by</label>
      <select id="rankBy">
        <option value="priority">Priority (default)</option>
        <option value="TotPop">Total population</option>
        <option value="Imperv_m">Impervious fraction</option>
      </select>
    </div>

    <div class="control-group">
      <label for="topN">N cities to display</label>
      <input id="topN" type="number" min="10" max="500" step="10" value="100" />
    </div>

    <div class="control-group">
      <label>Hazard weight w<sub>H</sub></label>
      <div class="range-row">
        <input id="wH" type="range" min="0.2" max="0.8" step="0.05" value="0.6" />
        <div class="pill" id="wHLabel">0.60</div>
      </div>
    </div>
  </div>

  <div class="layout">
    <div id="map"></div>

    <aside class="side">
      <div class="city-title">
        <h2 id="cityName">Click a city</h2>
        <div class="badge" id="tierBadge">—</div>
      </div>

      <div class="muted" id="cityMeta">Use the map to select a city and inspect drivers.</div>

      <div class="mini">
        <div class="box">
          <div class="k">Priority</div>
          <div class="v" id="priorityVal">—</div>
        </div>
        <div class="box">
          <div class="k">Hazard (H)</div>
          <div class="v" id="hazVal">—</div>
        </div>
        <div class="box">
          <div class="k">Vulnerability (1−S)</div>
          <div class="v" id="vulVal">—</div>
        </div>
      </div>

      <div id="bar"></div>

      <div class="kv" id="kv"></div>

      <div class="status" id="status">Loading cities…</div>
    </aside>
  </div>

  <div class="about">
    <h3>How to interpret this tool</h3>
    <ul>
      <li><strong>Hazard (H)</strong> is a weighted composite: H = 0.55·FloodSus + 0.35·DrouSus + 0.10·FireSus.</li>
      <li><strong>Adaptive Capacity (S)</strong> combines normalized per-capita GDP and HDI: S = 0.40·GDPpc<sub>norm</sub> + 0.60·HDI<sub>norm</sub>. Vulnerability is V = 1 − S.</li>
      <li><strong>Priority</strong> blends hazard and vulnerability using the slider w<sub>H</sub>: Priority = 100·(w<sub>H</sub>·H + (1−w<sub>H</sub>)·V).</li>
      <li><strong>Tiers</strong> are defined within the current filtered set using percentiles of Priority: Tier 1 ≥ P90, Tier 2: P75–P90, Tier 3: P50–P75, Tier 4 &lt; P50.</li>
      <li><strong>Map encoding:</strong> dot size ∝ population (log-scaled); dot color = Tier.</li>
    </ul>
    <p class="muted">
      Data source: city zonal statistics file exported from your workflow. This is a static page intended for GitHub Pages.
    </p>
  </div>

<script>
// ============================= CONFIG =====================================
// If you prefer a lighter payload, use the provided cities.json (array of objects)
// instead of the GeoJSON. Both can be generated from your shapefile.
const DATA_URL = 'cities.json';

// Tier colors (simple, high-contrast)
const TIER_STYLE = {
  1: { fill: '#d73027', stroke: '#111', label: 'Tier 1 (Immediate)' },
  2: { fill: '#fc8d59', stroke: '#111', label: 'Tier 2 (High)' },
  3: { fill: '#fee08b', stroke: '#111', label: 'Tier 3 (Moderate)' },
  4: { fill: '#91bfdb', stroke: '#111', label: 'Tier 4 (Lower)' },
  NA:{ fill: '#cccccc', stroke: '#111', label: '—' }
};

// ============================= STATE ======================================
let cities = [];   // array of GeoJSON features
let map, layerGroup;
let currentMarkers = [];
let lastSelectedId = null;

// ============================= HELPERS ====================================
function fmt(x, d=2) {
  if (x === null || x === undefined || Number.isNaN(x)) return 'NA';
  return Number(x).toFixed(d);
}

function fmtInt(x) {
  if (x === null || x === undefined || Number.isNaN(x)) return 'NA';
  return Math.round(Number(x)).toLocaleString('en-US');
}

function percentile(values, p) {
  if (!values.length) return NaN;
  const v = values.slice().sort((a,b)=>a-b);
  const idx = (p/100) * (v.length - 1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if (lo === hi) return v[lo];
  const w = idx - lo;
  return v[lo]*(1-w) + v[hi]*w;
}

function popClass(totPop) {
  const p = Number(totPop || 0);
  if (p > 1_000_000) return '>1M';
  if (p >= 500_000) return '500k-1M';
  if (p >= 250_000) return '250k-500k';
  if (p >= 100_000) return '100k-250k';
  return '<100k';
}

function markerRadius(totPop) {
  // log scale between ~3 and 14 px
  const p = Math.max(1, Number(totPop || 1));
  const r = 2.5 + 3.2 * Math.log10(p);
  return Math.max(3, Math.min(14, r));
}

function computeScores(feature, wH) {
  const pr = feature.properties;

  // Hazard components (assumed already in [0,1])
  const flood = Number(pr.FloodSus_m);
  const drou  = Number(pr.DrouSus_m);
  const fire  = Number(pr.FireSus_m);
  const H = 0.55*flood + 0.35*drou + 0.10*fire;

  // Socio index S is precomputed in the GeoJSON as SocioIndex
  const S = Number(pr.SocioIndex);
  const V = 1 - S;

  const priority = 100 * (wH*H + (1-wH)*V);

  return { H, S, V, priority, flood, drou, fire };
}

function setStatus(msg) {
  document.getElementById('status').textContent = msg;
}

function setTierBadge(tier) {
  const el = document.getElementById('tierBadge');
  const st = TIER_STYLE[tier] || TIER_STYLE.NA;
  el.textContent = st.label;
  el.style.background = st.fill;
  el.style.borderColor = '#111';
}

function renderBar(scores) {
  const div = document.getElementById('bar');
  if (!scores) {
    Plotly.react(div, [], {margin:{l:40,r:10,t:10,b:30}}, {responsive:true});
    return;
  }

  const x = [scores.H, scores.V];
  const y = ['Hazard (H)', 'Vulnerability (1−S)'];

  const data = [{
    type: 'bar',
    x, y,
    orientation: 'h',
    hovertemplate: '%{y}: %{x:.2f}<extra></extra>'
  }];

  const layout = {
    margin: { l: 130, r: 10, t: 8, b: 35 },
    xaxis: {
      range: [0, 1],
      title: '',
      zeroline: false,
      showgrid: false,
      ticks: 'outside',
      tickwidth: 2,
      linewidth: 2,
      linecolor: '#000'
    },
    yaxis: {
      zeroline: false,
      showgrid: false,
      ticks: 'outside',
      tickwidth: 2,
      linewidth: 0,
      automargin: true
    },
    showlegend: false
  };

  Plotly.react(div, data, layout, {responsive:true, displayModeBar:false});
}

function updateSidebar(feature, tier, scores) {
  const pr = feature.properties;
  const name = pr.ADM2_NAME || 'Unknown city';
  document.getElementById('cityName').textContent = name;

  const meta = `${pr.ADM1_NAME || '—'}, ${pr.ADM0_NAME || '—'}`;
  document.getElementById('cityMeta').textContent = meta;

  document.getElementById('priorityVal').textContent = scores ? fmt(scores.priority, 1) : '—';
  document.getElementById('hazVal').textContent = scores ? fmt(scores.H, 2) : '—';
  document.getElementById('vulVal').textContent = scores ? fmt(scores.V, 2) : '—';

  setTierBadge(tier);
  renderBar(scores);

  // Key-value table (keep it short and planner-friendly)
  const kv = document.getElementById('kv');
  const gdpPc = pr.GDPpc === null || pr.GDPpc === undefined ? null : Number(pr.GDPpc);

  const rows = [
    ['Population', fmtInt(pr.TotPop)],
    ['Pop. density (mean)', fmt(pr.PopDen_m, 0)],
    ['Impervious fraction (mean)', fmt(pr.Imperv_m, 2)],
    ['HDI (mean)', fmt(pr.HDI_m, 3)],
    ['GDP per cap (raw)', gdpPc ? `$${Math.round(gdpPc).toLocaleString('en-US')}` : 'NA'],
    ['FloodSus', fmt(pr.FloodSus_m, 2)],
    ['DrouSus', fmt(pr.DrouSus_m, 2)],
    ['FireSus', fmt(pr.FireSus_m, 2)],
    ['Human Mod. (mean)', fmt(pr.HMI_m, 2)]
  ];

  kv.innerHTML = rows.map(([k,v]) => `
    <div class="k">${k}</div><div>${v}</div>
  `).join('');
}

// ============================= FILTERING ==================================
function getUI() {
  const wH = Number(document.getElementById('wH').value);
  const country = document.getElementById('country').value;
  const state = document.getElementById('state').value;
  const popClassSel = document.getElementById('popClass').value;
  const rankBy = document.getElementById('rankBy').value;
  const topN = Math.max(10, Math.min(500, Number(document.getElementById('topN').value || 100)));
  return { wH, country, state, popClassSel, rankBy, topN };
}

function applyFilters() {
  const ui = getUI();
  document.getElementById('wHLabel').textContent = ui.wH.toFixed(2);

  // 1) filter by country/state/pop class
  let subset = cities.filter(f => {
    const p = f.properties;
    if (ui.country !== 'All' && p.ADM0_NAME !== ui.country) return false;
    if (!document.getElementById('state').disabled && ui.state !== 'All' && p.ADM1_NAME !== ui.state) return false;
    if (ui.popClassSel !== 'all' && popClass(p.TotPop) !== ui.popClassSel) return false;
    return true;
  });

  if (!subset.length) {
    setStatus('No cities match the current filters.');
    renderMarkers([]);
    return;
  }

  // 2) compute scores for subset
  const scored = subset.map(f => {
    const s = computeScores(f, ui.wH);
    return { f, s };
  });

  // 3) compute tier thresholds within subset
  const priorities = scored.map(o => o.s.priority).filter(v => Number.isFinite(v));
  const p50 = percentile(priorities, 50);
  const p75 = percentile(priorities, 75);
  const p90 = percentile(priorities, 90);

  scored.forEach(o => {
    const pr = o.s.priority;
    let tier = 4;
    if (pr >= p90) tier = 1;
    else if (pr >= p75) tier = 2;
    else if (pr >= p50) tier = 3;
    else tier = 4;
    o.tier = tier;
  });

  // 4) ranking for display
  const ranked = scored.slice().sort((a,b) => {
    if (ui.rankBy === 'priority') return b.s.priority - a.s.priority;
    const av = Number(a.f.properties[ui.rankBy] || 0);
    const bv = Number(b.f.properties[ui.rankBy] || 0);
    return bv - av;
  });

  const shown = ranked.slice(0, ui.topN);

  // 5) render
  renderMarkers(shown);

  setStatus(
    `Showing top ${shown.length} cities (out of ${subset.length} in current filters). ` +
    `Tier thresholds within filtered set: P50=${p50.toFixed(1)}, P75=${p75.toFixed(1)}, P90=${p90.toFixed(1)}.`
  );

  // if previously selected city is still visible, keep it highlighted
  if (lastSelectedId) {
    const hit = shown.find(o => o.f.properties.CITY_ID === lastSelectedId);
    if (hit) {
      updateSidebar(hit.f, hit.tier, hit.s);
    }
  }
}

// ============================= MAP ========================================
function renderMarkers(scoredArray) {
  layerGroup.clearLayers();
  currentMarkers = [];

  scoredArray.forEach(o => {
    const f = o.f;
    const s = o.s;
    const tier = o.tier;

    const [lon, lat] = f.geometry.coordinates;
    const style = TIER_STYLE[tier] || TIER_STYLE.NA;

    const marker = L.circleMarker([lat, lon], {
      radius: markerRadius(f.properties.TotPop),
      color: style.stroke,
      weight: 1.2,
      fillColor: style.fill,
      fillOpacity: 0.85
    });

    marker.on('click', () => {
      lastSelectedId = f.properties.CITY_ID;
      updateSidebar(f, tier, s);

      // subtle highlight: increase outline
      currentMarkers.forEach(m => m.setStyle({weight: 1.2}));
      marker.setStyle({weight: 3});
    });

    const popup = `<b>${f.properties.ADM2_NAME}</b><br>${f.properties.ADM1_NAME}, ${f.properties.ADM0_NAME}<br>` +
                  `Priority: ${s.priority.toFixed(1)} (${TIER_STYLE[tier].label})`;
    marker.bindTooltip(popup, {sticky:true});

    marker.addTo(layerGroup);
    currentMarkers.push(marker);
  });
}

// ============================= UI POPULATION ==============================
function populateFilters() {
  const countryEl = document.getElementById('country');
  const stateEl = document.getElementById('state');

  const countries = Array.from(new Set(cities.map(f => f.properties.ADM0_NAME))).sort();
  countryEl.innerHTML = ['All', ...countries].map(c => `<option value="${c}">${c}</option>`).join('');

  function refreshStates() {
    const c = countryEl.value;
    if (c === 'All') {
      stateEl.disabled = true;
      stateEl.innerHTML = `<option value="All">All</option>`;
      return;
    }
    const states = Array.from(new Set(cities.filter(f => f.properties.ADM0_NAME === c).map(f => f.properties.ADM1_NAME))).sort();
    stateEl.disabled = false;
    stateEl.innerHTML = ['All', ...states].map(s => `<option value="${s}">${s}</option>`).join('');
  }

  countryEl.addEventListener('change', () => {
    refreshStates();
    applyFilters();
  });

  stateEl.addEventListener('change', applyFilters);
  document.getElementById('popClass').addEventListener('change', applyFilters);
  document.getElementById('rankBy').addEventListener('change', applyFilters);
  document.getElementById('topN').addEventListener('change', applyFilters);
  document.getElementById('wH').addEventListener('input', applyFilters);

  refreshStates();
}

// ============================= LOAD =======================================
async function load() {
  // Map init
  map = L.map('map', { zoomControl: true }).setView([-18, -60], 4);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 18,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  layerGroup = L.layerGroup().addTo(map);

  try {
    const resp = await fetch(DATA_URL, {cache:'no-cache'});
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    // data can be either a GeoJSON FeatureCollection or an array of city objects
    if (Array.isArray(data)) {
      cities = data;
    } else {
      cities = (data && data.features) ? data.features.map(ft => {
        const p = ft.properties || {};
        const c = ft.geometry && ft.geometry.coordinates ? ft.geometry.coordinates : [null, null];
        return Object.assign({}, p, {lon: c[0], lat: c[1]});
      }) : [];
    }

    populateFilters();
    applyFilters();

    setStatus('Loaded. Use filters to explore.');
  } catch (e) {
    console.error(e);
    setStatus('Error loading data. Make sure cities_points.geojson is in the same folder as index.html.');
  }
}

document.addEventListener('DOMContentLoaded', load);
</script>
</body>
</html>
